<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="xesam" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      Android Context基础！ 
      
      
      |
    
     xesam.github.io
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <!-- <a href="/">
      
        <img src="/images/avatar.png" alt="">
      
    </a> -->
    <div class="nickname"><a href="/">Just Do IT</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.10/dist/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Android Context基础！</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <!-- <i class="iconfont icon-updatetime mr-10" title="更新时间"></i> -->
          <!-- 2025-04-16 16:32:33 -->
          <i class="iconfont icon-updatetime mr-10"></i>
          2015-05-17 12:46:04
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/android/" title="android">
                    <b>#</b> android
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="标签"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/android/" title="android">
                    #android
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>英文原文：<a target="_blank" rel="noopener" href="http://possiblemobile.com/2013/06/context/">Context, What Context?</a></p>
<p>译文Github地址:<a target="_blank" rel="noopener" href="https://github.com/xesam/tech-translate/blob/master/android/Context-What_Context.md">Context, What Context?</a></p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context 估计是 Android 开发中最常用的元素了，它的获取和使用如此普遍，加载资源，启动新的 Activity，获取系统服务，获取内部文件路径以及创建 View 都离不开 Context。同时，Context 也是最容易误操作的元素，以致于很容易把你带到坑里面去。下面就让我们全面对比了解一下 Context，让你的开发更得心应手。</p>
<h2 id="Context-类型"><a href="#Context-类型" class="headerlink" title="Context 类型"></a>Context 类型</h2><p>不同类型的Context各异：根据 Android 组件的不同，获得到的 Context 也是不同的。</p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>Application 是存在于 app 进程的一个单例 Context 对象。在 Activity 或者 Service 中，可以使用 getApplication() 方法获取这个 Application 对象。除此之外，从他继承了 Context 的组件，都可以通过 getApplicationContext() 来获取到这个 Application 对象。不过，不论是通过什么方法获得，最后得到的 Application 对象都是同一个。</p>
<p><em>【译者注：这个单例 Context 对象在后文用 application context 指代】</em></p>
<h3 id="Activity-Service"><a href="#Activity-Service" class="headerlink" title="Activity&#x2F;Service"></a>Activity&#x2F;Service</h3><p>Activity&#x2F;Service 继承自同一个基类 Context —— ContextWrapper，因此两者拥有相同的 Context API，但是具体任务还是通过将调用委托代理给实际的内部对象来完成。每当你创建一个新的 Activity 或者 Service 的时候，同时就会创建一个新的 ContextImpl，ContextImpl 就是最终处理所有 Context API 方法的内部对象。不同的Activity 或者 Service 的 Context 都是不一样的。</p>
<h3 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><p>BroadcastReceiver 本身并不是一个 Context，但是 Android framework 会在每一个广播事件发生的时候，给相应 BroadcastReceiver 的 onReceive() 传递一个 Context，这个 ReceiverRestrictedContext 有个两个方法不可用： registerReceiver() 和 bindService()。BroadcastReceiver 每次处理 broadcast 的时候，传递给它的 Context 都是一个新的实例。</p>
<h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>ContentProvider 本身也不是 Context，但是调用 getContext() 可以获取一个 Context。如果调用者与 ContentProvider 运行在同一个进程内，那么这个返回的 Context 就是上文的 application context。如果调用者与 ContentProvider 不是运行在同一个进程之内，那么这个方法会返回一个指代 provider 所在包的新 Context 实例。</p>
<h2 id="保存-Context-引用"><a href="#保存-Context-引用" class="headerlink" title="保存 Context 引用"></a>保存 Context 引用</h2><p>第一个问题：当我们将一个 Context 的引用保存到一个存活时间比 Context 本身生命周期还长的对象时，问题就来了。比如，我们有一个单例对象，要求使用一个 Context 来执行资源加载或访问 ContentProvider，并且传入的是一个 Activity 或 Service 对象：</p>
<p>错误的 Singleton 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CustomManager sInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CustomManager <span class="title function_">getInstance</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> <span class="title class_">CustomManager</span>(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CustomManager</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，单例对象是一个静态变量，受其所在类的生命周期控制。这就意味着，在这个单例对象的存活时间内，这个单例持有的对象（引用）都不会被垃圾回收。<br>所以这种实现的问题就是你无法知道 Context 到底来自何处，如果这个 Context 是一个 Activity 或者 Service， 就会变得不安全：这个被持有的 Activity，以及其内部所有的 View 或者其他的耗内存对象都无法被回收，从而引发内存泄露。</p>
<p>为了防止这种问题，我们改为让单例持有 application context：</p>
<p>改进的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CustomManager sInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CustomManager <span class="title function_">getInstance</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Always pass in the Application Context</span></span><br><span class="line">            sInstance = <span class="keyword">new</span> <span class="title class_">CustomManager</span>(context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CustomManager</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此以来，我们就不用再关心 Context 来自哪里，也不用关心 Context 是什么类型，因为最终持有的都会是 application context，因此就避免了内存泄露的问题。这个处理技巧在后台线程或者 Handler 处理中同样有效。</p>
<p>既然如此，是不是意味着我们可以在任何情况下都用 application context 来处理呢？这样就永远不用担心内存泄露了。答案显然是否定的，就如上文说的一样，不同情况下的 Context 各不相同。这就像葫芦娃一样，虽然都是葫芦娃，但是每个娃的技能都不一样。</p>
<h2 id="Context-特点"><a href="#Context-特点" class="headerlink" title="Context 特点"></a>Context 特点</h2><p>Context 能实现哪些功能，主要还是取决于 Context 从何而来，下表列出了不同 Context 的一些不同点：</p>
<table border="1" width="90%" align="center">
<thead>
<tr>
<th></th>
<th align="center">Application</th>
<th align="center">Activity</th>
<th align="center">Service</th>
<th align="center">ContentProvider</th>
<th align="center">BroadcastReceiver</th>
</tr>
</thead>
<tbody>
<tr>
<td>Show a Dialog</td>
<td align="center">NO</td>
<td align="center">YES</td>
<td align="center">NO</td>
<td align="center">NO</td>
<td align="center">NO</td>
</tr>
<tr>
<td>Start an Activity</td>
<td align="center">NO<sup>1</sup></td>
<td align="center">YES</td>
<td align="center">NO<sup>1</sup></td>
<td align="center">NO<sup>1</sup></td>
<td align="center">NO<sup>1</sup></td>
</tr>
<tr>
<td>Layout Inflation</td>
<td align="center">NO<sup>2</sup></td>
<td align="center">YES</td>
<td align="center">NO<sup>2</sup></td>
<td align="center">NO<sup>2</sup></td>
<td align="center">NO<sup>2</sup></td>
</tr>
<tr>
<td>Start a Service</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
</tr>
<tr>
<td>Bind to a Service</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">NO</td>
</tr>
<tr>
<td>Send a Broadcast</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
</tr>
<tr>
<td>Register BroadcastReceiver</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">NO<sup>3</sup></td>
</tr>
<tr>
<td>Load Resource Values</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
</tr>
</tbody>
</table>

<ol>
<li>application context 可以启动 Activity， 但是前提是需要创建一个新任务。在某些情况下，我们可以使用这种方式实现某种特殊目的，这种方式会创建一个非标准的回退栈，一般不推荐使用，至少不是一个好的实践。</li>
<li>这个是合法的调用，但是 inflation 获得的 View 只会应用系统的主题，而不是当前 app 的自定义主题。</li>
<li>在 4.2 及以上系统版本中， 允许注册 receiver 为 null 的广播监听，主要目的是为了获取 sticky broadcast 的当前值。</li>
</ol>
<h2 id="User-Interface"><a href="#User-Interface" class="headerlink" title="User Interface"></a>User Interface</h2><p>从上面的列表可以看到，application context 不能胜任很多场景，而且都是与UI相关的情况。实际上，只有 Activity 拥有处理 UI 的能力，其他类型的 Context 在这方面都大同小异。</p>
<p>上面的三种行为，除了 Activity， 其他的 Context 也都无法处理，从而避免误用。试图显示一个使用 application context 创建的 Dialog，或者从 application context 启动一个Activity，都会导致 app 崩溃，系统通过这种方式告诉你：你用错了。</p>
<p>另一个问题就是 inflating layout。如果你读过 <a target="_blank" rel="noopener" href="http://www.doubleencore.com/2013/05/layout-inflation-as-intended/">layout inflation</a>一文， 你就会知道 inflating layout 有一些容易让人迷惑的地方，如何正确使用 Context 就是其中一个。如果你使用 application context 来进行 inflating layout，并不会发生任何错误，但是当前 app 所定义的 themes 以及 styles 都被忽略了。究其原因，正如你在 manifest 中定义的一样， 只有 Activity 才是唯一能够响应 themes 定义的组件。任何其他组件所含有的 Context 都会应用 Android 系统自身的主题，所以，最终的 UI 表现可能出乎你的意料。</p>
<h2 id="规则冲突"><a href="#规则冲突" class="headerlink" title="规则冲突"></a>规则冲突</h2><p>可能有人会提出这样一种场景：在 app 的当前设计下，由于涉及到处理 UI 的操作，所以需要长期持有一个 Activity 的引用。如果是这样的话，我只能说：请重新考虑你的设计。</p>
<h2 id="经验法则"><a href="#经验法则" class="headerlink" title="经验法则"></a>经验法则</h2><p>简而言之，在组件的生命周期之内可以直接使用自身的 Context， 一旦需要在超出组件生命周期之外的对象中使用 Context ，就应该只用 application context，哪怕只是临时的引用，也是如此。</p>

      </div>
      <div class="post-copyright">转载请标注原地址：<a href="https://xesam.github.io/2015/05/17/android/2015/2015-05-17-Android-Context-basic/">https://xesam.github.io/2015/05/17/android/2015/2015-05-17-Android-Context-basic/</a></div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2015/05/03/talk/2015-05-03-talk-business/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
              2025-04-16 16:32:33
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/android/" title="android">
                        <b>#</b> android
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="标签"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/android/" title="android">
                        #android
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2015/06/08/android/2015/2015-06-08-Android-how-to-ButterKnife/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Context"><span class="toc-text">Context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context-%E7%B1%BB%E5%9E%8B"><span class="toc-text">Context 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Application"><span class="toc-text">Application</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity-Service"><span class="toc-text">Activity&#x2F;Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BroadcastReceiver"><span class="toc-text">BroadcastReceiver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ContentProvider"><span class="toc-text">ContentProvider</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98-Context-%E5%BC%95%E7%94%A8"><span class="toc-text">保存 Context 引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context-%E7%89%B9%E7%82%B9"><span class="toc-text">Context 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#User-Interface"><span class="toc-text">User Interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E5%86%B2%E7%AA%81"><span class="toc-text">规则冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E9%AA%8C%E6%B3%95%E5%88%99"><span class="toc-text">经验法则</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/xesam">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
        <li>
          
            <a title="email" href="mailto:xesam@outlook.com">
              <i class="iconfont icon-envelope"></i>
            </a>
            
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a href="https://xesam.github.io/">Copyright © 2025</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://hexo.io">Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        


        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        

      </div>
    </div>
  </body>
</html>
