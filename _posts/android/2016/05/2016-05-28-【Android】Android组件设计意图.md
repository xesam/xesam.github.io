---
layout: post
title:  "【Android】Android组件设计意图"
date:   2016-05-28 08:00:00 +0800
categories: Android
---

“我应该如何设计我的 Andr​​oid 应用？我应该使用哪种MVC模式？我应该如何使用事件总线？”

我们经常听到 Andr​​oid 平台开发工程师被问到类似的关于设计模式与应用程序架构的 App 开发问题。
但是答案也许令人惊讶：我们对此并没有统一或者强制的规范。

（PS：我这里写的“我们”讲的是 Android 平台的开发团队，而不是说所有的 Google 或 Android 应用开发者。
关于如何编写的应用程序，Google 内外都有有很多很好的建议和意见。）

使用 MVC？或者MVP？还是使用 MVVM？我无法给你答案。实际上，我在学校的时候只了解过MVC，其他的选项是从网上搜索而来的。

这可能令人惊讶，因为 Android 应用开发者可能觉得 Android 开发团队应该有一个指导意见来指导 APP 的开发。
凭借其Java语言的API和较高层次的概念，它可以看起来像一个典型的应用程序框架，
有说应用程序应该怎么做他们的工作。
但在情况不是这样的。

实际上，称 Android 的核心 API 为“System Framework”更合适。
很大程度上，Android API 定义的是应用程序与操作系统之间的交互行为，至于任何应用程序的内部逻辑，Android API 并不关心。

这就是说，在Android的API通常可以从看什么人在一个操作系统，这可能容易导致混淆，他们应该如何使用通常预计的不同（或更高级别）。

对于这样的一个例子，让我们考虑一个操作系统是如何定义“如何运行一个应用程序。”在一个典型的系统中，这基本上已与约当它应该运行的应用程序的合同：

INT主（...）{
   //我的应用程序放在这里！
}

所以在操作系统启动的应用程序，调用它的main（）函数，以及应用程序熄灭，运行和做它想要什么，直到它决定它完成。并明确这是什么也不说这里什么应用程序应该做或应该如何的主要功能内进行设计 - 这是一个非常纯粹的空白的石板。

在Android中，然而，我们明确地决定我们不会有一个main（）函数，因为我们需要给这个平台在如何应用程序运行更多的控制。特别是，我们想建立在用户考虑启动和停止的应用程序从未需要一个系统，而该系统考虑到了这个他们......所以系统必须有关于什么是里面发生了一些更多的信息每个应用程序的，并能够在无论何时它，即使它目前没有运行时所需的各种良好定义的方式启动应用程序。

要做到这一点，我们分解了应用程序的典型主入口点到几个不同类型的交互系统可以与它。而这些活动，广播接收器，服务和ContentProvider的API，这些API Android开发很快就熟悉了。

这些类可能看起来像他们告诉你如何您的应用程序的内部应该工作，但他们都没有！事实上，他们都是关于你的应用程序需要如何与系统（以及系统能协调其与其他应用程序交互）进行交互。只要与系统的相互作用情况，我们并不真正关心什么那张应用程序内。

为了说明这一点，让我们来简单了解一下这些不同的API，他们真正的意思是Android系统。

活动

这是在进入用于与用户交互的应用程序。从系统的角度来看，它与应用程序提供的关键相互作用是：

•跟踪哪些用户当前关心的（屏幕上显示内容），以确保保持运行的进程托管。
•知道以前使用过程包含事物的用户可以返回到（停止活动），从而更高度优先保持围绕这些进程。
•帮助应用程序处理哪里，它的进程被杀死，这样用户可以返回到活动，他们以前的状态恢复的情况。
•提供一种方法为应用程序实现用户彼此之间流动，由系统协调。 （最典型的例子是在这里份额）。

我们不关心：

一旦我们在这个入口点到你的用户界面已经得到了，我们真的不在乎你如何组织内的流动。让这一切一项活动具有手动改变其观点，用片段（便利框架内，我们提供），或者一些其他的框架，或将其分割成额外的内部活动。或根据需要做的所有三个。只要您遵循活动的高级别接触（它会启动处于正常状态，并保存/在当前状态恢复），它无关紧要系统。

广播接收器

这是该系统交付事件可能是外部的普通用户流的应用的机制。最重要的是，因为这是另一个良好定义的进入该应用中，系统可以提供广播来应用程式，即使它们不是当前正在运行。因此，例如，一个应用程序可以安排一个警报发布的通知，告诉即将发生的事件的用户...并通过提供报警到应用程序的一个BroadcastReceiver，没有必要为应用程序保持运行，直到警报响起。

我们不关心：

一个应用程序内调度事件是完全不同的事情。无论您是使用一些事件总线架构，实现自己的回调系统，无论...没有理由要使用系统的广播机制，因为你没有调度跨应用程序的事件。 （事实上​​，有很好的理由不 - 有很多不必要的开销和很多潜在的安全问题，如果使用的内部实现应用程序的全球广播机制）。我们做提供一个实现纯粹的LocalBroadcastManager方便的类-Process意向调度系统类似的API，以系统的API的，如果你碰巧喜欢他们。但同样，没有理由使用，超过其他的东西去纯粹的你的应用程序中的东西。

服务

一般用途的切入点保持应用程序在后台运行的各种理由。实际上有两个非常明显的语义服务讲述如何管理应用系统：

启动服务只是告诉系统，出于某种原因，“让我跑，直到我说我做的。”这可能是同步的背景某些数据或播放音乐的用户离开该应用甚至之后。这也代表了两种不同类型的修改系统如何处理它们启动的服务：

•音乐播放一些用户直接感知的，所以应用程序说，它希望与一个通知它告诉用户前台告诉系统这一点;在这种情况下，系统知道它应该尝试真的很难保持该服务的进程在运行，因为如果它消失了，用户会不高兴。

•定期后台服务是不是用户直接感知跑步，所以系统在管理其进程更多的自由。它可以允许它被杀死（然后晚些时候重新启动服务）如果需要的东西是更直接的关注​​的用户的RAM。

绑定服务正在运行，因为一些其他应用程序（或系统）曾表示，它希望使用该服务的。这基本上是提供API到另一个进程的服务。因此系统知道有这些过程之间的相关性，因此，如果过程A被绑定到在过程B中的服务时，它知道它需要保持处理B（和它的服务）运行A.此外，如果过程A是事用户关心的，比它也知道治疗进程B的东西，用户也在乎。

由于其灵活性（或好或坏）的，服务已经被证明是对各种高层次的系统概念，​​一个非常有用的组成部分。动态壁纸，通知监听器，屏幕保护程序，输入法，无障碍服务等诸多核心系统功能都做成了应用程序实现服务和系统结合时，它们应该被运行。

我们不关心：

Android不关心的事情你的应用程序，没有对应该如何管理过程产生任何影响中去，因此没有理由在这些情况下使用的服务。例如，如果要启动一些后台运行，下载数据，你的UI，你不应该使用服务这一点 - 它实际上是非常重要的不是告诉系统，让您的进程中运行，而这样做，因为它真的并不需要，系统会更好与其它事物的用户正在做管理它具有更多的自由。

如果你只是做一个简单的后台线程（或任何你想要的非服务机制）做下载，你会得到你想要的语义：当用户在你的UI，系统将让您的过程中运行的，所以下载将永远不会被中断。当他们离开你的UI，你的进程仍将保持左右（缓存），并能为没有其他地方需要用到它的RAM，继续下载，为长。

同样，用于连接您的应用程序的不同部分组合在一起，没有理由绑定到在同一个进程中运行的一种结合到它的服务。这样做是不积极有害 - 系统只是看到从过程本身因此不尽量保持周围比平时更多的依赖 - 但它是一堆的为您和系统不必要的工作。相反，你可以只使用单件或其他正常过程中的模式，用于连接您的应用程序的拼凑。

的ContentProvider

最后，ContentProvider的是从应用程序到其他地方发布的数据相当专门的设施。人们一般把它们看成一个数据库上的抽象，因为有很多的API和内置于他们对于常见的情况的支持......但是从制度设计的角度来看，这不是他们的观点。

这是什么意思的系统是一个入口点成发布命名的数据项，由URI标识方案的应用程序。因此，一个应用程序可以决定如何想它包含一个URI命名空间中的数据映射，发放这些URI的其他实体可以反过来用它们来访问数据。有一些特别的东西，这个允许系统在管理应用程序做的：

•派一个URI不需要的应用程序仍然正常运行，所以这些可以去各地的拥有应用程序是死的地方。仅仅在有人告诉系统来看，“哎给我数据，这个​​URI”它需要确保应用程序拥有的数据运行，因此它可以让应用程序检索并返回数据。

•这些URI还提供了一个重要的细粒度的安全模型。例如，一个应用程序可以将URI作为它在剪贴板上的图像，但其留下内容供应商锁定了，所以没有人可以自由访问它。当另一个应用程序就会将该URI关闭剪贴板，该系统可以给它一个临时的“URI权限授予”使得它允许访问只落后URI的数据，但在应用程序没有别的。

我们不关心：

它并不真正的问题你如何实现内容提供商背后的数据管理;如果你不需要在SQLite数据库结构化数据，不使用的SQLite。例如，FileProvider辅助类是一种简单的方法来通过内容提供商您的应用程序提供原始数据文件。

另外，如果你不是从你的应用程序供他人使用发布数据，就没有必要使用内容提供商在所有。这是真的，因为各地的内容提供商建立了各种各样的帮手，这样可以将数据在SQLite数据库，并使用它来填充像一个ListView UI元素的简单方法。但是，如果任何这方面的东西，使你正在尝试做更多的困难，然后随意不使用它，而是使用更合适的数据模型为您的应用程序。